namespace Algorithms;

using static BitTools;

[TestFixture]
public class BitToolsTest
{
    /// <summary>
    ///     Test for BranchlessSignExtend(int n)
    /// </summary>
    [Test]
    [Ignore("BranchlessSignExtend is not yet implemented")]
    public void BranchlessSignExtendTest()
    {
        // var obj = new BitTools();
        // var expected = obj.BranchlessSignExtend();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "BranchlessSignExtend");
        Fail();
    }

    /// <summary>
    ///     Test for BranchlessSignExtend(long n)
    /// </summary>
    [Test]
    [Ignore("BranchlessSignExtend2 is not yet implemented")]
    public void BranchlessSignExtend2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.BranchlessSignExtend();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "BranchlessSignExtend");
        Fail();
    }

    /// <summary>
    ///     Test for LeastPowerOfTwoGreaterOrEqualTo(long n)
    /// </summary>
    [Test]
    [Ignore("LeastPowerOfTwoGreaterOrEqualTo is not yet implemented")]
    public void LeastPowerOfTwoGreaterOrEqualToTest()
    {
        // var obj = new BitTools();
        // var expected = obj.LeastPowerOfTwoGreaterOrEqualTo();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "LeastPowerOfTwoGreaterOrEqualTo");
        Fail();
    }

    /// <summary>
    ///     Test for LeastPowerOfTwoGreaterOrEqualTo(int n)
    /// </summary>
    [Test]
    [Ignore("LeastPowerOfTwoGreaterOrEqualTo2 is not yet implemented")]
    public void LeastPowerOfTwoGreaterOrEqualTo2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.LeastPowerOfTwoGreaterOrEqualTo();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "LeastPowerOfTwoGreaterOrEqualTo");
        Fail();
    }

    /// <summary>
    ///     Test for HasOneBit(long value)
    /// </summary>
    [Test]
    [Ignore("HasOneBit is not yet implemented")]
    public void HasOneBitTest()
    {
        // var obj = new BitTools();
        // var expected = obj.HasOneBit();
        // var actual = default(bool);
        // Assert.AreEqual(expected, actual, "HasOneBit");
        Fail();
    }

    /// <summary>
    ///     Test for MaxBits(long bits)
    /// </summary>
    [Test]
    [Ignore("MaxBits is not yet implemented")]
    public void MaxBitsTest()
    {
        // var obj = new BitTools();
        // var expected = obj.MaxBits();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "MaxBits");
        Fail();
    }

    /// <summary>
    ///     Test for RotateLeft(uint bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateLeft is not yet implemented")]
    public void RotateLeftTest()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateLeft();
        // var actual = default(uint);
        // Assert.AreEqual(expected, actual, "RotateLeft");
        Fail();
    }

    /// <summary>
    ///     Test for RotateRight(uint bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateRight is not yet implemented")]
    public void RotateRightTest()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateRight();
        // var actual = default(uint);
        // Assert.AreEqual(expected, actual, "RotateRight");
        Fail();
    }

    /// <summary>
    ///     Test for RotateLeft(int bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateLeft2 is not yet implemented")]
    public void RotateLeft2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateLeft();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "RotateLeft");
        Fail();
    }

    /// <summary>
    ///     Test for RotateRight(int bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateRight2 is not yet implemented")]
    public void RotateRight2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateRight();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "RotateRight");
        Fail();
    }

    /// <summary>
    ///     Test for RotateLeft31(int bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateLeft31 is not yet implemented")]
    public void RotateLeft31Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateLeft31();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "RotateLeft31");
        Fail();
    }

    /// <summary>
    ///     Test for RotateRight31(int bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateRight31 is not yet implemented")]
    public void RotateRight31Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateRight31();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "RotateRight31");
        Fail();
    }

    /// <summary>
    ///     Test for RotateLeft(ulong bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateLeft3 is not yet implemented")]
    public void RotateLeft3Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateLeft();
        // var actual = default(ulong);
        // Assert.AreEqual(expected, actual, "RotateLeft");
        Fail();
    }

    /// <summary>
    ///     Test for RotateRight(ulong bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateRight3 is not yet implemented")]
    public void RotateRight3Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateRight();
        // var actual = default(ulong);
        // Assert.AreEqual(expected, actual, "RotateRight");
        Fail();
    }

    /// <summary>
    ///     Test for RotateLeft(long bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateLeft4 is not yet implemented")]
    public void RotateLeft4Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateLeft();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "RotateLeft");
        Fail();
    }

    /// <summary>
    ///     Test for RotateRight(long bits, int n = 1)
    /// </summary>
    [Test]
    [Ignore("RotateRight4 is not yet implemented")]
    public void RotateRight4Test()
    {
        // var obj = new BitTools();
        // var expected = obj.RotateRight();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "RotateRight");
        Fail();
    }

    /// <summary>
    ///     Test for Reverse(int value)
    /// </summary>
    [Test]
    [Ignore("Reverse is not yet implemented")]
    public void ReverseTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Reverse();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Reverse");
        Fail();
    }

    /// <summary>
    ///     Test for GetUnsigned(long data, int pos, int bits)
    /// </summary>
    [Test]
    [Ignore("GetUnsigned is not yet implemented")]
    public void GetUnsignedTest()
    {
        // var obj = new BitTools();
        // var expected = obj.GetUnsigned();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "GetUnsigned");
        Fail();
    }

    /// <summary>
    ///     Test for GetSigned(long data, int pos, int bits)
    /// </summary>
    [Test]
    [Ignore("GetSigned is not yet implemented")]
    public void GetSignedTest()
    {
        // var obj = new BitTools();
        // var expected = obj.GetSigned();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "GetSigned");
        Fail();
    }

    /// <summary>
    ///     Test for GetUnsigned(int data, int pos, int bits)
    /// </summary>
    [Test]
    [Ignore("GetUnsigned2 is not yet implemented")]
    public void GetUnsigned2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.GetUnsigned();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "GetUnsigned");
        Fail();
    }

    /// <summary>
    ///     Test for GetSigned(int data, int pos, int bits)
    /// </summary>
    [Test]
    [Ignore("GetSigned2 is not yet implemented")]
    public void GetSigned2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.GetSigned();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "GetSigned");
        Fail();
    }

    /// <summary>
    ///     Test for Set(long data, int pos, int bits, long val)
    /// </summary>
    [Test]
    [Ignore("Set is not yet implemented")]
    public void SetTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Set();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "Set");
        Fail();
    }

    /// <summary>
    ///     Test for Set(int data, int pos, int bits, int val)
    /// </summary>
    [Test]
    [Ignore("Set2 is not yet implemented")]
    public void Set2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Set();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Set");
        Fail();
    }

    /// <summary>
    ///     Test for RemoveLastBit(int value)
    /// </summary>
    [Test]
    [Ignore("RemoveLastBit is not yet implemented")]
    public void RemoveLastBitTest()
    {
        // var obj = new BitTools();
        // var expected = obj.RemoveLastBit();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "RemoveLastBit");
        Fail();
    }

    /// <summary>
    ///     Test for Count(long x)
    /// </summary>
    [Test]
    [Ignore("Count is not yet implemented")]
    public void CountTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Count();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Count");
        Fail();
    }

    /// <summary>
    ///     Test for Count1(ulong x)
    /// </summary>
    [Test]
    [Ignore("Count1 is not yet implemented")]
    public void Count1Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Count1();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Count1");
        Fail();
    }

    /// <summary>
    ///     Test for Count2(ulong x)
    /// </summary>
    [Test]
    [Ignore("Count2 is not yet implemented")]
    public void Count2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Count2();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Count2");
        Fail();
    }

    /// <summary>
    ///     Test for Count3(ulong x)
    /// </summary>
    [Test]
    [Ignore("Count3 is not yet implemented")]
    public void Count3Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Count3();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Count3");
        Fail();
    }

    /// <summary>
    ///     Test for CountOptimised(uint i)
    /// </summary>
    [Test]
    [Ignore("CountOptimised is not yet implemented")]
    public void CountOptimisedTest()
    {
        // var obj = new BitTools();
        // var expected = obj.CountOptimised();
        // var actual = default(uint);
        // Assert.AreEqual(expected, actual, "CountOptimised");
        Fail();
    }

    /// <summary>
    ///     Test for CountHackMem(uint i)
    /// </summary>
    [Test]
    [Ignore("CountHackMem is not yet implemented")]
    public void CountHackMemTest()
    {
        // var obj = new BitTools();
        // var expected = obj.CountHackMem();
        // var actual = default(uint);
        // Assert.AreEqual(expected, actual, "CountHackMem");
        Fail();
    }

    /// <summary>
    ///     Test for Negate(int bits, int mod=32)
    /// </summary>
    [Test]
    [Ignore("Negate is not yet implemented")]
    public void NegateTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Negate();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Negate");
        Fail();
    }

    /// <summary>
    ///     Test for Add(int bits1, int bits2)
    /// </summary>
    [Test]
    [Ignore("Add is not yet implemented")]
    public void AddTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Add();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Add");
        Fail();
    }

    /// <summary>
    ///     Test for Mod(int bits, int mod)
    /// </summary>
    [Test]
    [Ignore("Mod is not yet implemented")]
    public void ModTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Mod();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Mod");
        Fail();
    }

    /// <summary>
    ///     Test for Negate(long bits, int mod = 64)
    /// </summary>
    [Test]
    [Ignore("Negate2 is not yet implemented")]
    public void Negate2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Negate();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "Negate");
        Fail();
    }

    /// <summary>
    ///     Test for Add(long bits1, long bits2)
    /// </summary>
    [Test]
    [Ignore("Add2 is not yet implemented")]
    public void Add2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Add();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "Add");
        Fail();
    }

    /// <summary>
    ///     Test for Mod(long bits, int mod)
    /// </summary>
    [Test]
    [Ignore("Mod2 is not yet implemented")]
    public void Mod2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Mod();
        // var actual = default(long);
        // Assert.AreEqual(expected, actual, "Mod");
        Fail();
    }

    /// <summary>
    ///     Test for EstimateTreeDepth(int leafCount)
    /// </summary>
    [Test]
    [Ignore("EstimateTreeDepth is not yet implemented")]
    public void EstimateTreeDepthTest()
    {
        // var obj = new BitTools();
        // var expected = obj.EstimateTreeDepth();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "EstimateTreeDepth");
        Fail();
    }

    /// <summary>
    ///     Test for Log2Original(int value)
    /// </summary>
    [Test]
    [Ignore("Log2Original is not yet implemented")]
    public void Log2OriginalTest()
    {
        // var obj = new BitTools();
        // var expected = obj.Log2Original();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Log2Original");
        Fail();
    }

    /// <summary>
    ///     Test for Log2(int value)
    /// </summary>
    [Test]
    [Ignore("Log2 is not yet implemented")]
    public void Log2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Log2();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Log2");
        Fail();
    }

    /// <summary>
    ///     Test for AlternateLog2(long value)
    /// </summary>
    [Test]
    [Ignore("AlternateLog2 is not yet implemented")]
    public void AlternateLog2Test()
    {
        // var obj = new BitTools();
        // var expected = obj.AlternateLog2();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "AlternateLog2");
        Fail();
    }

    /// <summary>
    ///     Test for Log2(long value)
    /// </summary>
    [Test]
    [Ignore("Log3 is not yet implemented")]
    public void Log3Test()
    {
        // var obj = new BitTools();
        // var expected = obj.Log2();
        // var actual = default(int);
        // Assert.AreEqual(expected, actual, "Log2");
        Fail();
    }

    [Test]
    public void NumberOfTrailingZerosTest()
    {
        unchecked {
            const int Mask = 0x5555_5555;

            for (int i = 0; i < 32; i++)
                AreEqual(i, NumberOfTrailingZeros(1 << i));
            for (int i = 0; i < 32; i++)
                AreEqual(i, NumberOfTrailingZeros(Mask << i));
            for (int i = 0; i < 32; i++)
                AreEqual(i, NumberOfTrailingZeros(15 << i));
            AreEqual(0, NumberOfTrailingZeros(-1));
            AreEqual(32, NumberOfTrailingZeros(0));
        }
    }

    [Test]
    public void NumberOfTrailingZerosLongTest()
    {
        const long Mask = 0x5555_5555_5555_5555;

        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(1L << i));
        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(Mask << i));
        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(15L << i));
        AreEqual(0, NumberOfTrailingZeros(-1L));
        AreEqual(64, NumberOfTrailingZeros(0L));
    }

    [Test]
    public void NumberOfTrailingZerosULongTest()
    {
        const ulong Mask = 0x5555_5555_5555_5555;

        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(1UL << i));
        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(Mask << i));
        for (int i = 0; i < 32; i++)
            AreEqual(i, NumberOfTrailingZeros(15UL << i));
        AreEqual(0, NumberOfTrailingZeros(~0UL));
        AreEqual(64, NumberOfTrailingZeros(0UL));
    }

    [Test]
    public void NumberOfLeadingZerosIntTest()
    {
        const int Mask = unchecked((int)0xcccccccc);

        AreEqual(32, NumberOfLeadingZeros(0));
        for (int i = 0; i < 32; i++)
            AreEqual(31 - i, NumberOfLeadingZeros(1 << i));
        for (int i = 0; i < 32; i++)
            AreEqual(31 - i, NumberOfLeadingZeros(ShiftRight(Mask, ~i)));
    }

    [Test]
    public void NumberOfLeadingZerosLongTest()
    {
        const long Mask = unchecked((long)0xcccccccc_cccccccc);

        AreEqual(64, NumberOfLeadingZeros(0L));
        for (int i = 0; i < 32; i++)
            AreEqual(63 - i, NumberOfLeadingZeros(1L << i));
        for (int i = 0; i < 32; i++)
            AreEqual(63 - i, NumberOfLeadingZeros(ShiftRight(Mask, ~i)));
    }

    [Test]
    public void NumberOfLeadingZerosUnsignedLongTest()
    {
        const ulong Mask = 0xcccccccc_cccccccc;

        AreEqual(64, NumberOfLeadingZeros(0UL));
        for (int i = 0; i < 32; i++)
            AreEqual(63 - i, NumberOfLeadingZeros(1UL << i));
        for (int i = 0; i < 32; i++)
            AreEqual(63 - i, NumberOfLeadingZeros(Mask >> ~i));
    }

    [Test]
    public void LowestOneBitTest()
    {
        const int Mask = 0x5555_5555;

        for (int i = 0; i < 32; i++)
            AreEqual(1 << i, LowestOneBit(1 << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1 << i, LowestOneBit(Mask << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1 << i, LowestOneBit(15 << i));
        AreEqual(1, LowestOneBit(-1));
        AreEqual(0, LowestOneBit(0));
    }

    [Test]
    public void LowestOneBitLongTest()
    {
        const long Mask = 0x5555_5555_5555_5555;

        for (int i = 0; i < 32; i++)
            AreEqual(1L << i, LowestOneBit(1L << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1L << i, LowestOneBit(Mask << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1L << i, LowestOneBit(15L << i));
        AreEqual(1, LowestOneBit(-1L));
        AreEqual(0, LowestOneBit(0L));
    }

    [Test]
    public void LowestOneBitULongTest()
    {
        const ulong Mask = 0x5555_5555_5555_5555;

        for (int i = 0; i < 32; i++)
            AreEqual(1UL << i, LowestOneBit(1UL << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1UL << i, LowestOneBit(Mask << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1UL << i, LowestOneBit(15UL << i));
        AreEqual(1, LowestOneBit(~0UL));
        AreEqual(0, LowestOneBit(0UL));
    }

    [Test]
    public void HighestOneBitIntTest()
    {
        const int Mask = unchecked((int)0xcccccccc);

        AreEqual(0, HighestOneBit(0));
        for (int i = 0; i < 32; i++)
            AreEqual(1 << i, HighestOneBit(1 << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1 << i, HighestOneBit(ShiftRight(Mask, ~i)));
    }

    [Test]
    public void HighestOneBitLongTest()
    {
        const long Mask = unchecked((long)0xcccccccc_cccccccc);

        AreEqual(0, HighestOneBit(0L));
        for (int i = 0; i < 32; i++)
            AreEqual(1L << i, HighestOneBit(1L << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1L << i, HighestOneBit(ShiftRight(Mask, ~i)));
    }

    [Test]
    public void HighestOneBitUnsignedLongTest()
    {
        const ulong Mask = 0xcccccccc_cccccccc;

        AreEqual(0, HighestOneBit(0UL));
        for (int i = 0; i < 32; i++)
            AreEqual(1UL << i, HighestOneBit(1UL << i));
        for (int i = 0; i < 32; i++)
            AreEqual(1UL << i, HighestOneBit(Mask >> ~i));
    }

    [Test]
    public void ShiftRightIntTest()
    {
        AreEqual(0, ShiftRight(0));
        AreEqual(int.MaxValue, ShiftRight(-1));
        AreEqual(1 << 22, ShiftRight(1 << 23));
    }

    [Test]
    public void ShiftRightLongTest()
    {
        AreEqual(0, ShiftRight(0L));
        AreEqual(long.MaxValue, ShiftRight(-1L));
        AreEqual(1L << 22, ShiftRight(1L << 23));
    }

    [Test]
    public void LogUsingFloatTest()
    {
        Console.WriteLine($"0 -> {LogUsingFloat(0)}");
        IsTrue(LogUsingFloat(0) < 0);

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            int j = LogUsingFloat(b);

            Console.WriteLine($"1 << {i} = {b} -> {j}");
            AreEqual(i, LogUsingFloat(b));
        }
    }

    [Test]
    public void LogUsingFloat2Test()
    {
        Console.WriteLine($"0 -> {LogUsingFloatLShift(0)}");
        //IsTrue(LogUsingFloat2(0) < 0);

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            int j = LogUsingFloatLShift(b);
            Console.WriteLine($"1 << {i} = {b} -> {j}");
            // AreEqual(i, j);
        }
    }

    [Test]
    public void LogUsingFloat2cTest()
    {
        Console.WriteLine($"0 -> {LogUsingFloatDShift(0)}");
        //IsTrue(LogUsingFloat2(0) < 0);

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            int j = LogUsingFloatDShift(b);
            Console.WriteLine($"1 << {i} = {b} -> {j}");
            AreEqual(i, j);
        }
    }

    [Test]
    public void HighestBitUsingFloatTest()
    {
        Console.WriteLine($"0 -> {HighestBitUsingFloat(0)}");
        //AreEqual(0, HighestBitUsingFloat(0));

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            long j = HighestBitUsingFloat(b);
            Console.WriteLine($"1 << {i} = {b} -> {j}");
            AreEqual(b, j);
        }
    }

    [Test]
    public void HighestBitUsingFloat2Test()
    {
        Console.WriteLine($"0 -> {HighestBitUsingFloatCompactAccurateZero(0)}");
        AreEqual(0, HighestBitUsingFloatCompactAccurateZero(0));

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            long j = HighestBitUsingFloatCompactAccurateZero(b);
            Console.WriteLine($"1 << {i} = {b} -> {j}");
            AreEqual(b, j);
        }
    }

    [Test]
    public void HighestBitUsingFloat4Test()
    {
        Console.WriteLine($"0 -> {HighestBitUsingFloatRoundTrip(0)}");
        //AreEqual(0, HighestBitUsingFloat4(0));

        for (int i = 0; i < 64; i++) {
            long b = 1L << i;
            long j = HighestBitUsingFloatRoundTrip(b);
            Console.WriteLine($"1 << {i} = {b} -> {j}");
            AreEqual(b, j);
        }
    }

    public void Time(string label, Action action)
    {
        var stopwatch = new Stopwatch();
        stopwatch.Start();
        for (int i = 0; i < 1000; i++)
            action();
        stopwatch.Stop();
        TimeSpan elapsed = stopwatch.Elapsed;
        Console.WriteLine(label + ":");
        Console.WriteLine("  " + elapsed);
    }

    const int Runs = 1000;

    [Test]
    public void PerformanceHighestBit()
    {
        Time("HighestBitUsingFloatIncorrectZero-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestBitUsingFloat(b);
            }
        });

        Time("HighestBitUsingFloatIncorrectZero-int", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestBitUsingFloat(b);
            }
        });

        Time("HighestBitUsingFloatCompact-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestBitUsingFloatCompactAccurateZero(b);
            }
        });

        Time("HighestBitUsingFloatCompact-int", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestBitUsingFloatCompactAccurateZero(b);
            }
        });

        Time("HighestBitUsingFloatAccurateZero", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestBitUsingFloatAccurateZero(b);
            }
        });

        Time("HighestBitUsingFloatAccurateZero", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestBitUsingFloatAccurateZero(b);
            }
        });

        Time("HighestBitUsingMask-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestBitUsingMask(b);
            }
        });

        Time("HighestBitUsingMask-int", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestBitUsingMask(b);
            }
        });

        Time("HighestBitUsingFloatRoundTrip", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestBitUsingFloatRoundTrip(b);
            }
        });

        Time("HighestBitUsingFloatRoundtrip", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestBitUsingFloatRoundTrip(b);
            }
        });

        Time("HighestBit-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                HighestOneBit(b);
            }
        });

        Time("HighestBit-int", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                HighestOneBit(b);
            }
        });

        // HighestBitUsingFloat64: 00:00:00.1727932
        // HighestBitUsingFloat32: 00:00:00.2044373

        // HighestBit64: 00:00:01.0399817
        // HighestBit32: 00:00:00.9577022

        // HighestBit64 is 5% slower than 32bit version
        // Float-based is 5x faster
    }

    [Test]
    public void PerformanceLog2()
    {
        Time("Warmup", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingFloat(b);
            }
        });

        Time("LogUsingFloat-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingFloat(b);
            }
        });

        Time("LogUsingFloat-int", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                LogUsingFloat(b);
            }
        });

        Time("LogUsingFloat_5-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingFloat_5(b);
            }
        });

        Time("LogUsingFloatLShift-long", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingFloatLShift(b);
            }
        });

        Time("Log2_64", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                Log2(b);
            }
        });

        Time("Log2_32", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                Log2(b);
            }
        });

        Time("LogUsingFloatDShift", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingFloatDShift(b);
            }
        });

        Time("LogUsingDebruinLong", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                long b = 1L << i;
                LogUsingDeBruin(b);
            }
        });

        Time("LogUsingDebruinInt", () => {
            for (int j = 0; j < Runs; j++)
            for (int i = 0; i < 32; i++) {
                int b = 1 << i;
                LogUsingDeBruin(b);
            }
        });
    }

    public void NoOp(long x) { }

    [Test]
    public void PerformanceMod()
    {
        const long shift = 1234567890123;
        const long MOD = 1000000007;
        const int iter = 32000;
        const double d = 1.0 / MOD;

        Time("Warmup", () => {
            for (long i = shift * iter; i >= 0; i -= shift) {
                long x = i % MOD;
                NoOp(x);
            }
        });

        Time("Mod", () => {
            for (long i = shift * iter; i >= 0; i -= shift) {
                long x = i % MOD;
                NoOp(x);
            }
        });

        Time("ModThroughFloatingPointMult", () => {
            for (long i = shift * iter; i >= 0; i -= shift) {
                long x = i - MOD * (long)(i * d);
                NoOp(x);
            }
        });
    }

    public static unsafe long HighestBitUsingFloatCompactAccurateZero(long x)
    {
        // 4x faster
        double f = (ulong)x; // |1
        return unchecked((1L << ((((int*)&f)[1] >> 20) - 1023)) & ~(((x - 1) & (-x - 1)) >> 63));
    }

    public static unsafe long HighestBitUsingFloatCompactAccurateZero(int x)
    {
        // 4x faster
        double f = unchecked((uint)x); // |1
        return unchecked((1L << ((((int*)&f)[1] >> 20) - 1023)) & ~(((x - 1) & (-x - 1)) >> 31));
    }

    public static unsafe long HighestBitUsingFloatAccurateZero(long x)
    {
        // 4x faster
        double f = unchecked((ulong)x); // |1
        return unchecked((1L << ((((int*)&f)[1] >> 20) - 1023)) & ~(((x - 1) >> 63) & ((-x - 1) >> 63)));
    }

    public static unsafe long HighestBitUsingFloatAccurateZero(int x)
    {
        // 4x faster
        double f = unchecked((uint)x);
        return unchecked((((1L << ((int*)&f)[1]) >> 20) - 1023) & ~(((x - 1) >> 31) & ((-x - 1) >> 31)));
    }

    public static unsafe long HighestBitUsingFloat(long x)
    {
        // 5x faster
        double f = (ulong)x;
        return unchecked(1L << ((((int*)&f)[1] >> 20) - 1023));
    }

    public static unsafe int HighestBitUsingFloat(int x)
    {
        // 5x faster
        double f = unchecked((uint)x);
        return unchecked(1 << ((((int*)&f)[1] >> 20) - 1023));
    }

    public static unsafe long HighestBitUsingFloatRoundTrip(long x)
    {
        double f = unchecked((ulong)x);
        *(ulong*)&f &= 0xfff0000000000000; // -1L << 52;
        return unchecked((long)(ulong)f);

        //float f = unchecked((ulong)x);
        //*(uint*)&f &= 0xff800000; // -1L << 52;
        //return unchecked((long)(ulong)f);
    }

    public static unsafe int HighestBitUsingFloatRoundTrip(int x)
    {
        double f = unchecked((uint)x);
        *(long*)&f &= -1L << 52;
        return unchecked((int)(uint)f);
    }

    public static long HighestBitUsingMask(long x)
    {
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        x |= x >> 32;
        return x & unchecked((long)~((ulong)x >> 1));
    }

    public static int HighestBitUsingMask(int x)
    {
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return x & ~(x >> 1);
    }

    // Almost 4x faster
    public static unsafe int LogUsingFloat(long x)
    {
        double f = unchecked((ulong)x);
        return unchecked((((int*)&f)[1] >> 20) - 1023);
    }

    // Over 3x faster
    public static unsafe int LogUsingFloat(int x)
    {
        double f = unchecked((ulong)x);
        return unchecked((((int*)&f)[1] >> 20) - 1023);
    }

    public static unsafe int LogUsingFloatLShift(long x)
    {
        double f = unchecked((ulong)x);
        return unchecked((int)(*(long*)&f >> 52) - 1023);
    }

    public static unsafe int LogUsingFloat_5(long x)
    {
        double f = unchecked((ulong)x + .5);
        return unchecked((((int*)&f)[1] >> 20) - 1023);
    }

    public static unsafe int LogUsingFloatDShift(long x)
    {
        double f = unchecked((ulong)x * 1.112537e-308);
        return unchecked(((int*)&f)[1] >> 20);
    }

    static readonly byte[] tab64 =
    {
        63, 0, 58, 1, 59, 47, 53, 2,
        60, 39, 48, 27, 54, 33, 42, 3,
        61, 51, 37, 40, 49, 18, 28, 20,
        55, 30, 34, 11, 43, 14, 22, 4,
        62, 57, 46, 52, 38, 26, 32, 41,
        50, 36, 17, 19, 29, 10, 13, 21,
        56, 45, 25, 31, 35, 16, 9, 12,
        44, 24, 15, 8, 23, 7, 6, 5,
    };

    public static int LogUsingDeBruin(long value)
    {
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value |= value >> 32;
        return unchecked(tab64[(ulong)((value - (value >> 1)) * 0x07EDD5E59A4E28C2) >> 58]);
    }

    static readonly byte[] tab32 =
    {
        0, 9, 1, 10, 13, 21, 2, 29,
        11, 14, 16, 18, 22, 25, 3, 30,
        8, 12, 20, 28, 15, 17, 24, 7,
        19, 27, 23, 6, 26, 5, 4, 31,
    };

    public static int LogUsingDeBruin(int value)
    {
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        return unchecked(tab32[(uint)(value * 0x07C4ACDD) >> 27]);
    }
    // private BitTools sample;

    //    public ulong DivMod(ulong x)
    //    {
    //        //692:  48 8b 45 f8 mov        rax,QWORD PTR[rbp - 0x8]
    //        //696:  48 ba e5 8f a2 12 31   movabs rdx,0x89705f3112a28fe5
    //        //69d:  5f 70 89
    //        //6a0:  48 f7 e2               mul rdx
    //        //6a3:  48 89 d0 mov           rax,rdx
    //        //6a6:  48 c1 e8 1d            shr rax,0x1d

    //        return  unchecked(x*0x89705f3112a28fe5) >> 0x1d;
    //    }

    //    public long DivMode(long x)
    //    {
    //        //700:  48 89 f8 mov            rax,rdi
    //        //703:  48 ba e5 8f a2 12 31    movabs rdx,0x89705f3112a28fe5
    //        //70a:  5f 70 89
    //        //70d:  48 f7 ea                imul rdx
    //        //710:  48 8d 04 3a lea         rax,[rdx+rdi*1]
    //        //714:  48 c1 ff 3f             sar rdi,0x3f
    //        //718:  48 c1 f8 1d             sar rax,0x1d
    //        //71c:  48 29 f8 sub            rax,rdi
    //        //71f:  c3 ret

    //        return unchecked(x* 0x89705f3112a28fe5)
    //}
}